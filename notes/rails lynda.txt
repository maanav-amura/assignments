=> MVC Architecture

Model (Library : ActiveRecord) - handles data, objects in the database
View  (Library : ActionView) - handles presentation, presentation(html, css, js)
Controller (Library : ActionController) - handles decision, events

=> Create rails project - rails new simple_cms -d mysql

Inside gem file, keep only required gems and remove all others and then run bundle install to configure dependencies i.e. bundle install
configure config/database.yml for database


=> Generate controller and view
rails generate controller demo index

=> Routes

Simple: get "demo/index"

Full:
match "demo/index"
	:to => "demo#index",
	:via => :get

Default route is based on :controller/:action/:id
Default routes -
match ':controller(/:action(/:id))', :via => :get

=> Render

To render a particular page for a controller's action use, e.g. in demo controller render view hello for index
def index
 #  render(:template => 'demo/hello')
 #  render('demo/hello')
    render('hello')
end

 def hello
    # If to render same view no need to explicitly mention render as render('hello')
 end

=> Redirection
  def other_hello
    # access as localhost:3000/other_hello
    # redirect_to(:controller => 'demo', :action=> 'index')
    redirect_to(:action=> 'index') # default controller
  end
  def google
    redirect_to('http://www.google.co.in')
  end

=> Embedded Ruby(erb)
process the text - <% %>
outputs the value it returns inside it  - <%= %>

=> To transfer data from controller to view, we use exclusively INSTANCE VARIABLES

demo_controller.rb
	 def hello
	   @array = [1,2,3,4,5]
	  end
hello.html.erb
	<% @array.each do |a| %>
	<br> <%= a %>
	<% end %>

=> HTML Links

<a href="/demo/index"> Index </a>
<%= link_to(text, target) %>
eg.	<%= link_to("Hello", {:controller => 'demo', :action => 'hello'}) %>
	<%= link_to("Hello", {:action => 'hello'}) %> # since demo is default controller

link_to helps to reduce url link to root as it has access to routes instead of full path,
hence displayed as 'localhost:3000' instead of 'localhost:3000/demo/index' just like redirect

=> URL parameters

Access as params[:id] or params['id']
In index.html.erb => <%= link_to("Hello with parameters", {:action => 'hello', :id => 10, :page => 'hello'}) %>
In demo_ontroller.rb => @id = params[:id]; @page = params['page']
In hello.html.erb => <%= @id %> <%= @page %> [Outputs => 10 hello]
Url changed as = 10?page=hello, before '?' its id as id is special and after ? are the other params
and ignores the instance variable when no params are passed

We can inspect the params present on page using '<%= params.inspect %>' in html.erb

=> Environments

Development : For developing the product
Production : When the application goes live, its put on the live server for public to use
Test : To test application and databases, without changing development or production Environments
We can also add any other Environments

=> Database

database -> table -> row -> column -> field
index, foreign keys(mostly indexed), schema, CRUD

Commands -
show databases;
create database simple_cms_development;
use simple_cms_development;

- grant all privileges on db_name.*
  to 'username'@'localhost'
  identified by 'password';
- show grants for 'username'@'localhost;'

mysql> GRANT ALL PRIVILEGES ON simple_cms_development.*
    -> TO 'simple_cms'@'localhost'
    -> IDENTIFIED BY 'amura@123';
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql> SHOW GRANTS FOR 'simple_cms'@'localhost';
+--------------------------------------------------------------------------------+
| Grants for simple_cms@localhost                                                |
+--------------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO 'simple_cms'@'localhost'                                 |
| GRANT ALL PRIVILEGES ON `simple_cms_development`.* TO 'simple_cms'@'localhost' |
+--------------------------------------------------------------------------------+

To logon directly with created user - mysql -u simple_cms -p simple_cms_development

=> rake = "Ruby make"

To connect and dump schema details to mysql:
$ rake db:schema:dump
$ rake -T     # returns all task available by rake
$ rake -T db for only db tasks
$ rake db:schema:dump RAILS_ENV=production    # for other environments

=> Migrations
- allows sharing schema change
- helps with vesion control
- allows different users to keep their database in sync
- writing in ruby instead of SQL

Generate Migrations
$ rails generate migration InitMigrations

Generate model
$ rails generate model User
      Model name is singular
      Database name is plural

application_controller < ActionController :: Base
application_record < ActiveRecord::Base

Migrations

db/migrate/init.rb

  class Init < ActiveRecord::Migration[5.1]
    def change

Model

db/migrate/20170822054430_create_subjects.rb
  class CreateSubjects < ActiveRecord::Migration[5.1]
    def change
      create_table :subjects do |t|

        t.timestamps
      end
    end
  end

app/models/subject.rb
  class Subject < ApplicationRecord

Create table inside migrations of model (create_users)
  create_table 'table' do |t|
    t.column 'name', :type, options
    t.type 'name', options

    t.timestamps    # created_at, updated_at
  end

Table column types = binary, boolean, date, datetime, decimal, float, integer, string, text, time
Table column options =
:limit => size
:default => false
:null => true/false
:precision => number
:scale => number

Once you have defined the create migrations use command '$ rake db:migrate' to migrate
and then schema is dumped into db/schema.rb

To revert back to initial migrations:
$ rake db:migrate VERSION=0

➜  simple_cms git:(master) ✗ rake db:migrate VERSION=0
== 20170821044937 InitMigrations: reverting ===================================
== 20170821044937 InitMigrations: reverted (0.0023s) ==========================

➜  simple_cms git:(master) ✗ rake db:migrate:status
 Status   Migration ID    Migration Name
--------------------------------------------------
  down    20170821044937  Init migrations
  down    20170821045157  Create users

  We can directly make use of version migrations specified in db:migrate:status

➜  simple_cms git:(master) ✗ rake db:migrate VERSION=20170821045157
== 20170821045157 CreateUsers: migrating ======================================

➜  simple_cms git:(master) ✗ rake db:migrate:status
 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20170821044937  Init migrations
   up     20170821045157  Create users

TABLE MIGRATIONS METHOD

- create_table(table, options) do |t|
end
- drop_table(table)
rename_table(table, new_name)

COLUMN MIGRATIONS METHOD

add_column(table, column, type, options)
remove_column(table, column )
rename_column(table, column, new_name)
change_column(table, column, type, options)

INDEX MIGRATION METHOD

add_index (table, column/[array of columns] , options)  # option - :unique => true/false, :name => "custom_name"
remove_index(table, column)

$ rails generate migration AlterUsers

class AlterUsers < ActiveRecord::Migration[5.1]
  def up
    rename_table('users','admin_users')
    add_column('admin_users', 'username', :string, :limit=>25, :after => 'email')
    change_column('admin_users','email',:string, :limit => 100)
    rename_column('admin_users','password','hashed_password')
    puts 'Adding index username!'
    add_index('admin_users','username')
  end
  def down
    remove_index('admin_users','username')
    rename_column('admin_users','hashed_password','password')
    change_column('admin_users','email',:string, :default=>'', :null => false)
    remove_column('admin_users', 'username')
    rename_table('admin_users','users')
  end
end

➜  simple_cms git:(master) ✗ rake db:migrate
➜  simple_cms git:(master) ✗ rake db:migrate version=0
➜  simple_cms git:(master) ✗ rake db:migrate:status

database: simple_cms_development

 Status   Migration ID    Migration Name
--------------------------------------------------
   up     20170821044937  Init migrations
   up     20170821045157  Create users
   up     20170821052228  Alter users

Migration advice: if there is any error while migrating, solve it, and comment what was done already

Add foreign key is similar to add a normal key:
      t.integer 'subject_id'
      # same as : t.references :subject

self.table_name = 'admin_users' # To configure a differnet table in Model.rb

=> Records

user = User.new
user.first_name = ' '
user.save # Insert
user.last_name = ' '
user.save # Update
user.delete

user = User.where(:first_name => 'kevin')
users = users.order('last_name ASC').limit(5)
users = users.include(:articles_authored)

=> Rails console

CREATE

> subject = Subject.new({:name => 'Subject 1', :position => 1, :visible => 1})
2.4.0 :009 > subject.inspect
2.4.0 :010 > subject.new_record?
 => true
2.4.0 :011 > subject.save
 => true
2.4.0 :012 > subject.new_record?
 => false
2.4.0 :013 > subject.id
 => 1

Directly create, instantiate and save the subject :
> subject = Subject.create({:name=>'Subject 2',:position=>2,:visible=>true})

UPDATE

subject = Subject.find(1)
subject.visible = false
subject.save


subject = Subject.find(2)
subject.update_attributes(:visible => false, :position => 2)

DELETE

subject = Subject.find(1)
subject.destroy / subject.delete        # objects get frozen and thus cant be modified
subject.name  # Is allowed and will return name, can be used to return an object that it is deleted
subject.name = '' # will throw an error

FIND

- Primary key finder

Subject.find(2)   # either returns an object or error

- Dynamic key finder

Subject.find_by_id(1)   # returns object or nil
Subject.find_by_name('Subject 1')   # does not throw an error
Subject.all
Subject.first
Subject.last


CHECKING TYPE

Array ["name = ? AND visible = TRUE", "m" ]
Hash {:name => 'm', :visible => true}

FIND

Subject.where(['visible=?',false]).where({:name=>'Subject 1'}).first
Subject.order('name ASC')
Subject.order('name DESC')
Subject.limit(1)
Subject.offset(1)


LAMBDAS AS FUNCTIONS

In subject.rb
  # Access from Rails console :  Subject.visible or subject = Subject.search('Sub')

  scope :latest, -> { order('position DESC') }

  scope :visible, lambda { where(:visible => true) }
  scope :invisible, lambda { where(:visible => false )}
  scope :sorted, lambda { order('subjects.position ASC') }    # where subjects is the table name in SQL
  scope :newest_first, lambda { order('subjects.created_at DESC') }
  scope :search, lambda { |query|
    where(['name like ?',"%#{query}%"])
  }

=> Associations

ONE-TO-ONE

Subject.rb                # Provides subject.page as output
  has_one :page

Page.rb                   # Create pages should have a subject_id column to hold the subject
  belongs_to :subject

console:
subject = Subject.find(1)
first = Page.new({:name => 'Page 1', :permalink => 'first', :position => 1})
subject.page = first        <Page id: 1, subject_id: 1, .. >
subject.page.destroy # to remove the relationship

ONE-TO-MANY

Subject.rb                # Provides subject.pages as output
  has_many :pages

Page.rb                   # Create pages should have a subject_id column to hold the subject
  belongs_to :subject

console:
subject = Subject.find(1)
subject.pages
subject.pages << page
subject.pages = [page1,page2,..]
subject.pages.clear
subject.pages.destroy(page)
subject.pages.delete(page)
subject.pages.empty?
subject.pages.size

subject = Subject.find(1)
first = Page.new({:name => 'Page 1', :permalink => 1, :position => 1})
second = Page.new({:name => 'Page 2', :permalink => 2, :position => 2})
subject.pages << first
subject.pages << second
subject.pages = [first,second]
subject.pages.size => 2
subject.pages.empty? => false
subject.pages.delete(second)
subject.pages.size => 1
subject.pages.destroy(first)

MANY-TO-MANY

Create a Join table used as - FirstTablName_SecondTblName

$ rails generate migration CreateUsersPagesJoin

    create_table :users_pages, :id => false do |t|
      t.integer 'user_id'
      t.integer 'page_id'

class User < ApplicationRecord
  has_and_belongs_to_many :pages, :join_table => 'users_pages'

class Page < ApplicationRecord
  has_and_belongs_to_many :editors, :class_name => 'User', :join_table => 'users_pages'

Console:
page = Page.find(3)
me = User.create({:first_name=>'maanav',:last_name=>'shah',:email=>'m@g.c',:username=>'m',:hashed_password=>'ms'})
page.editors << me
page.editors.each {|e| puts e.first_name}

RICH MANY-TO-MANY

class CreateSectionEdits < ActiveRecord::Migration[5.1]
  def change
    create_table :section_edits do |t|
      t.references :user
      t.references :section
      t.string :summary
      t.timestamps
    end
    add_index :section_edits, ['user_id','section_id']

User.rb
  has_many :section_edits

class Section < ApplicationRecord
  has_many :section_edits

class SectionEdit < ApplicationRecord
  belongs_to :editor, :class_name => 'User', :foreign_key=>'user_id'
  belongs_to :section

Console

me = User.find(1)
me.section_edits
section = Section.create({:name=>'Section 1',:position=>1})
section.section_edits
edit = SectionEdit.new
section.section_edits << edit
edit.editor = me ;  edit.save  OR   me.section_edits << edit

OR

SectionEdit.create({:editor => me, :section => section, :summary=> 'sdfsdf'})

ACCESSING RICH JOINS

class User < ApplicationRecord
  has_many :section_edits
  has_many :sections, :through=> :section_edits

class Section < ApplicationRecord
  has_many :section_edits
  has_many :editor, :class_name => 'User', :through => :section_edits

class SectionEdit < ApplicationRecord
  belongs_to :editor, :class_name => 'User', :foreign_key=>'user_id'
  belongs_to :section
end

Console

section.section_edits.map {|se| se.editor}
  SectionEdit Load (0.4ms)  SELECT `section_edits`.* FROM `section_edits` WHERE `section_edits`.`section_id` = 1
  User Load (0.3ms)  SELECT  `admin_users`.* FROM `admin_users` WHERE `admin_users`.`id` = 1 LIMIT 1
 => [#<User id: 1, first_name: "maanav", last_name: "shah", email: "m@g.c", username: "m", hashed_password: "ms", created_at: "2017-08-21 09:55:55", updated_at: "2017-08-21 09:55:55">]
2.4.0 :015 >

=> CRUD

-index, show
- new, create
- edit, update
- delete, destroy
generate a form_for controller in .html.erb and rails will render it
in controller, create a new instance to pass default value and in action method perform the action and then redirect

=> Layouts

<%= yield %>

You can create your own layout_name.html.erb and to use ut, in controller add line -> layout 'layout_name'
You can keep flash notices inside a single layout

also in layout title you can add   <title>CMS | <%= @page_title || 'Admin' %></title>
and in html add  <% @page_title = 'Subject' %>

=> Partial

To keep code dry in html, create any html.erb with name preceding with underscore eg. _form.html.erb
in _form.html.erb add all repeating code

and in html add lines
<%= form_for(:subject, :url => {:action => 'update', :id => @subject.id} ) do |f| %>
  <%= render(:partial => 'form', :locals => {:f => f}) %>
  <%= submit_tag('Update Subject')%>
<% end %>
to render the repeating code in html file

=> REST

Representational State Transfer(REST)
- no procedure
- state transfer
- provides api

HTTP Verbs
- get
- post
- put
- patch
- delete

Rails provides a hidden fields to access the REST Verbs that are not supported by HTML

<form method="post" action="123">
  <input type="hidden" name="_method" value="patch">
  ...
</form>

=> Form helpers

text_field, password_field, text_area, hidden_field, label, radio_button, check_box, file_field
